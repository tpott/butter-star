<html> 
<head> 
	<title> 
		French Maid
	</title> 
	<style> 
		html, body {
				width: 100%;
				height: 100%;
			}

			body {
				background-color: #ffffff;
				margin: 0;
				overflow: hidden;
				font-family: arial;
			}

			#blocker {

				position: absolute;

				width: 100%;
				height: 100%;

				background-color: rgba(0,0,0,0.5);

			}

			#instructions {

				width: 100%;
				height: 100%;

				display: -webkit-box;
				display: -moz-box;
				display: box;

				-webkit-box-orient: horizontal;
				-moz-box-orient: horizontal;
				box-orient: horizontal;

				-webkit-box-pack: center;
				-moz-box-pack: center;
				box-pack: center;

				-webkit-box-align: center;
				-moz-box-align: center;
				box-align: center;

				color: #ffffff;
				text-align: center;

				cursor: pointer;

			}
	</style> 
</head> 
<body> 
	<script src="https://raw.github.com/mrdoob/three.js/master/build/three.js"> </script> 
	<script src="js/loaders/MTLLoader.js"></script>
	<script src="js/loaders/OBJMTLLoader.js"></script>
	<script src="js/libs/stats.min.js"></script>
	<script src="js/THREEx.FullScreen.js"></script>
	<script src="js/PointerLockControls.js"></script>
	<script src="js/connection.js"></script>
	<script src="js/client.js"></script>
	<script> 
	
		//GLOBALS AND SHIT
		var scene = new THREE.Scene(); 
		var stats = new Stats();
		var camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 2000);
		var audio = document.createElement('audio');
		var source = document.createElement('source');
		var renderer = new THREE.WebGLRenderer(); 
		var geometry = new THREE.CubeGeometry(1,3,1); 
		var material = new THREE.MeshBasicMaterial({color: 0xffffff, map: THREE.ImageUtils.loadTexture("data/player.png")}); 
		var cube = new THREE.Mesh(geometry, material);
		var PI_2 = Math.PI / 2;
		var fullScreenMode = 0;
		
		
		//-------------------------------------------------------
		//HELPER FUNCTIONS AND SHIET
		//-------------------------------------------------------
		
		//clone: javascript doesnt like pass by value; use this to copy elements by value
		function clone(obj) {
		if (null == obj || "object" != typeof obj) return obj;
		var copy = obj.constructor();
		for (var attr in obj) {
			if (obj.hasOwnProperty(attr)) copy[attr] = obj[attr];
		}
			return copy;
		}
		
		
		//-------------------------------------------------------
		//FUNCTIONS AND SHIET
		//-------------------------------------------------------
		
		
		/*
			container for the player
		*/
		var player = {
		model : 
			{		
				objects : new THREE.Object3D(),
				motion  : 'stand',
				state   : 'stand'
			},
		position: 
			{
				x : 0,
				y : 0,
				z : 0,
				direction : 0
			},
		camera :
			{
				speed : 300,
				distance : 5,
				x : 0,
				y : 0,
				z : 0
			}
		}
		
		
		/**
		 * struct for movements
		 */
		var moveState = {
			moving    : false,
			front     : false,
			Backwards : false,
			left      : false,
			right     : false,
			sprinting : false,
			speed     : .25,
			angle     : 0
		}
		
		var moveState2 = {
			moving    : false,
			front     : false,
			Backwards : false,
			left      : false,
			right     : false,
			sprinting : false,
			speed     : .25,
			angle     : 0
		}
		
		/*
			detect movements
		*/
			var controls,time = Date.now();

			var objects = [];


			var havePointerLock = 'pointerLockElement' in document || 'mozPointerLockElement' in document || 'webkitPointerLockElement' in document;

		
		function move(){
		
		var speed = moveState.speed;
		//if(player.model.state === 'crstand'){speed *= .5;}
		//if(player.model.state === 'freeze') {speed *= 0;}
		if(moveState.sprinting == true)
		{
			moveState.speed = .75;
		}
		else
		{
			moveState.speed = .25;
		}
		
		var direction = moveState.angle;
		if( moveState.front && !moveState.left && !moveState.Backwards && !moveState.right){direction +=   0}
		if( moveState.front &&  moveState.left && !moveState.Backwards && !moveState.right){direction +=  45}
		if(!moveState.front &&  moveState.left && !moveState.Backwards && !moveState.right){direction +=  90}
		if(!moveState.front &&  moveState.left &&  moveState.Backwards && !moveState.right){direction += 135}
		if(!moveState.front && !moveState.left &&  moveState.Backwards && !moveState.right){direction += 180}
		if(!moveState.front && !moveState.left &&  moveState.Backwards &&  moveState.right){direction += 225}
		if(!moveState.front && !moveState.left && !moveState.Backwards &&  moveState.right){direction += 270}
		if( moveState.front && !moveState.left && !moveState.Backwards &&  moveState.right){direction += 315}
		
		player.model.objects.rotation.y = direction * Math.PI / 180;
		player.position.x -= Math.sin(direction * Math.PI / 180) * speed;
		player.position.z -= Math.cos(direction * Math.PI / 180) * speed;
		}
		
		
		
			
		document.addEventListener("fullscreenchange", function () {
			//console.log(document.fullscreen);
			fullScreenMode = (fullScreenMode == 1) ?  0 : 1;
			var element = document.body;
			element.requestPointerLock();
		}, false);
		document.addEventListener("mozfullscreenchange", function () {
			console.log(document.mozFullScreen);
			fullScreenMode = (fullScreenMode == 1) ?  0 : 1;
			var element = document.body;
			element.requestPointerLock();
		}, false);
		document.addEventListener("webkitfullscreenchange", function () {
			console.log(document.webkitIsFullScreen);
			console.log("yo this used webkitfullscreen");
			fullScreenMode = (fullScreenMode == 1) ?  0 : 1;
			var element = document.body;
			element.webkitRequestPointerLock();
		}, false);	
			
			
		/*
		check for key pressed from the player
		*/
		var timer;
		document.addEventListener('keydown', function(e){
			if(e.shiftKey == 1)
			{
				moveState2.sprinting = true;
			}
			if(e.shiftKey == 0)
			{
				moveState2.sprinting = false;
			}
			
			//'m' key
			if(e.keyCode == 77)
			{
				audio.pause();
			}
			
			switch(e.keyCode)
			{
				case 77: audio.pause();
						 break;
				default:
			}
			
			if( !/65|68|83|87/.test(e.keyCode)){ 
			
			send(moveState2);
			return; }
			
			switch(e.keyCode)
			{
				case 87:		//W
					moveState2.front     = true;
					moveState2.Backwards = false;
					break;
				case 65:		//A
					moveState2.left  = true;
					moveState2.right = false;
					break;
				case 83:		//S
					moveState2.Backwards = true;
					moveState2.front     = false;
					break;
				case 68:		//D
					moveState2.right = true;
					moveState2.left  = false;
					break;
				default:
					//console.log(e.keyCode);
			}
			
			if(!moveState2.moving){
				moveState2.moving = true;
				move();
				timer = setInterval( function(){
					move();
				}, 1000 / 60);
			}
			send(moveState2);
			
		}, false);
		
		document.addEventListener('keyup', function(e){
			if(e.shiftKey == 1)
			{
				moveState2.sprinting = false;
			}
			if(e.shiftKey == 0)
			{
				moveState2.sprinting = false;
			}
			switch(e.keyCode)
			{
				case 70: 		//F
					toggleFullScreen();
					//handleFullscreen();
					break;
				default:
					//console.log(e.keyCode);
			}
			
			if( !/65|68|83|87/.test(e.keyCode)){ send(moveState2);return; }
			
			switch(e.keyCode)
			{
				case 87:		//W
					moveState2.front = false;
					break;
				case 65:		//A
					moveState2.left = false;
					break;
				case 83:		//S
					moveState2.Backwards = false;
					break;
				case 68:		//D
					moveState2.right = false;
					break;
				
			}
			
			
			if(!moveState2.front && !moveState2.Backwards && !moveState2.left && !moveState2.right){
				moveState2.moving = false;
				clearInterval(timer);
			}
			send(moveState2);
		}, false);
		
		
		
		connection.onmessage = function(buf) {
		messages[messages.length] = buf.data;
		console.log("Client received: " + buf.data);
		//console.log(moveState);
		//console.log(buf.data);
		moveState = JSON.parse(buf.data);
		//console.log(moveState);
		//var something = JSON.parse(buf.data);
		
		
		};
		
	/**
	 * camera rotation
	 */
		var getElementPosition = function(element) 
		{
			var top = left = 0;
			do {
				top  += element.offsetTop  || 0;
				left += element.offsetLeft || 0;
				element =  element.offsetParent;
			}
			while (element);
			return {top: top, left: left};
		}
	
		var pointer = {x : 0, y : 0};
		var pointer2 = {x : 0, y : 0};
		document.addEventListener('mousemove', function(e){
			var mouseX = e.clientX - getElementPosition(renderer.domElement).left;
			var mouseY = e.clientY - getElementPosition(renderer.domElement).top;
			pointer.x =   (mouseX / renderer.domElement.width) * 2 - 1;
			pointer.y = - (mouseY / renderer.domElement.height) * 2 + 1;
		}, false);
		
		var oldPointerX = oldPointerY = oldPointer2X = oldPointer2Y = 0;
		document.addEventListener('mousedown', rotateStart, false);
		
		function rotateStart() {
			oldPointerX = pointer.x;
			oldPointerY = pointer.y;
			renderer.domElement.addEventListener('mousemove', rotate, false);
			renderer.domElement.addEventListener('mouseup', rotateStop, false);
		}
		
		function rotateStop() {
			renderer.domElement.removeEventListener('mousemove', rotate, false);
			renderer.domElement.removeEventListener('mouseup', rotateStop, false);
		}
		
		function rotate(){
			player.camera.x += (oldPointerX - pointer.x) * player.camera.speed;
			player.camera.y += (oldPointerY - pointer.y) * player.camera.speed;
			if(player.camera.y > 150){
				player.camera.y = 150;
			}
			if(player.camera.y < -150){
				player.camera.y = -150;
			}
			//console.log(player.camera.x, player.camera.y);
			moveState.angle = (player.camera.x / 2) % 360;
			
			oldPointerX = pointer.x;
			oldPointerY = pointer.y;
		}
		
		function rotate2(){
			player.camera.x -= (pointer2.x) * player.camera.speed;
			player.camera.y += (pointer2.y) * player.camera.speed;
			//console.log(player.camera.x, player.camera.y);
			
			if(player.camera.y > 150){
				player.camera.y = 150;
			}
			if(player.camera.y < -150){
				player.camera.y = -150;
			}
			moveState.angle = (player.camera.x / 2) % 360;
		}
		
		document.addEventListener( 'mousemove', function(event){
		//only do the on mouse move stuff if it is in fullscreen mode
		if(fullScreenMode == 1)
			{
				var movementX = event.movementX || event.mozMovementX || event.webkitMovementX || 0;
				var movementY = event.movementY || event.mozMovementY || event.webkitMovementY || 0;

				pointer2.y = movementY * 0.0004;
				pointer2.x = movementX * 0.0004;

				//console.log(pointer2.y, pointer2.x);
				
				
				rotate2();
				
				oldPointer2X = pointer.x;
				oldPointer2Y = pointer.y;
			}
		}
		,false );
		
		/*
		update the states of the game
		examples:
			player position
			monster positions
			calculation heavy stuff go here
		*/
		function update()
		{

			cube.position = clone(player.position);
			cube.position.y = -2;
			
			player.model.objects.position.x = player.position.x;
			player.model.objects.position.y = player.position.y;
			player.model.objects.position.z = player.position.z;
			
			// camera rotate x
			camera.position.x = player.position.x + player.camera.distance * Math.sin( (player.camera.x) * Math.PI / 360 );
			camera.position.z = player.position.z + player.camera.distance * Math.cos( (player.camera.x) * Math.PI / 360 );
			
			//camera rotate y
			camera.position.y = player.position.y + player.camera.distance * Math.sin( (player.camera.y) * Math.PI / 360 );
			camera.position.y += 1;
		
			//console.log(camera.position.z)
			
			var vec3 = new THREE.Vector3( player.position.x,  player.position.y,  player.position.z)
			camera.lookAt( vec3 );
		}
		
		/*
			renderin' shit
		*/
		function render()
		{ 
			requestAnimationFrame(render); 
			
			update();
			renderer.render(scene, camera); 
			stats.update();
		}
		
		//place to initialize lights (temporary, may not need)
		function initLights()
		{
				var light = new THREE.PointLight( 0xffffff, 1, 1000); light.position.set( 0, 50, 0 ); scene.add( light );
		}
		
		//place to initialize models (such as characters and maps)
		function initModels()
		{
			var loader = new THREE.OBJMTLLoader();
				loader.addEventListener( 'load', function ( event ) {

					var object = event.content;
					var tempScale = new THREE.Matrix4();
					object.position.y = -5;
					object.position.x = -20;
					object.scale.set(.1,.1,.1);
					scene.add( object );

				});
			loader.load( 'data/forest/KokiriForest.obj', 'data/forest/KokiriForest.mtl' );
		}
		
		//load them textures here
		function initTextures()
		{
			var neheTexture;
			function initTexture() {
			neheTexture = gl.createTexture();
			neheTexture.image = new Image();
			neheTexture.image.onload = function()
			{
				handleLoadedTexture(neheTexture)
			}

			neheTexture.image.src = "data/player.png";
			}
		}
		
		//load sound clips here
		function initSounds()
		{
		
			
			source.src = 'data/sounds/Paris2.ogg';
			audio.appendChild(source);
			audio.play();
		}
		
		//initialize the fps counter
		function initStats()
		{
			stats.domElement.style.position = 'absolute';
			stats.domElement.style.top = '0px';
			stats.domElement.style.zIndex = 100;
		}
		
		function toggleFullScreen()
		{
			if( THREEx.FullScreen.activated() )
			{
				THREEx.FullScreen.cancel();
			}
			else
			{
				var element = document.body;
						// Ask the browser to lock the pointer
					element.requestPointerLock = element.requestPointerLock || element.mozRequestPointerLock || element.webkitRequestPointerLock;

				

				element.requestFullscreen = element.requestFullscreen || element.mozRequestFullscreen || element.mozRequestFullScreen || element.webkitRequestFullscreen;

				element.requestFullscreen();
			}
		}
		
		function main()
		{
			initStats();
			initLights();
			initModels();
			initTextures();
			initSounds();
			audio.pause();
			//controls.disable;
			
			//camera = new THREE.PerspectiveCamera( 75, window.innerWidth / window.innerHeight, 1, 1000 );
			renderer.setSize(window.innerWidth, window.innerHeight); 
			document.body.appendChild(renderer.domElement); 
			document.body.appendChild( stats.domElement );
			window.addEventListener( 'resize', onWindowResize, false );
			scene.add(cube); 

			
			render(); 
		}
		
		function onWindowResize() {

				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();

				renderer.setSize( window.innerWidth, window.innerHeight );

			}
		

		main();
		
	</script> 
</body> 
</html> 
